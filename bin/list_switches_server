#!/usr/bin/env ruby

require 'pathname'
require 'socket'
require 'fileutils'
require 'bindata'

class ListSwitchesRequest < BinData::Record
  endian :big

  uint8 :version, :initial_value => 0
  uint8 :message_type
  uint16 :tag
  uint32 :message_length
  
  uint32 :transaction_id
  uint16 :service_name_length
  uint16 :padding
  stringz :service_name, :read_length => :service_name_length
end

class ListSwitchesReply < BinData::Record
  endian :big

  uint8 :version, :value => 0
  uint8 :message_type, :value => 2
  uint16 :tag, :value => 0
  uint32 :message_length, :value => lambda { num_bytes }

  uint32 :transaction_id
  uint16 :service_name_length, :value => 0
  uint16 :padding, :value => 0
  array :dpids, :type => :uint64, :initial_length => 0
end

def socket_file(service_name)
  Pathname(__dir__).join('..', 'tmp', 'sock', "trema.#{service_name}.sock").to_s
end

begin
  read_socket = Socket.new(:UNIX, :SOCK_SEQPACKET, 0)
  read_socket.bind(Addrinfo.unix(socket_file('switch_manager')))
  read_socket.listen(Socket::SOMAXCONN)
  client, client_addr_info = read_socket.accept
  request_binary, sender_addrinfo = client.recvfrom(100000)
  request = ListSwitchesRequest.read(request_binary)
  puts request.inspect
  
  reply = ListSwitchesReply.new(:transaction_id => request['transaction_id'], :dpids => [0x1, 0x2, 0x3, 0x4])
  write_socket = Socket.new(:UNIX, :SOCK_SEQPACKET, 0)
  write_socket.connect(Addrinfo.unix(socket_file(request['service_name'])))
  write_socket.write(reply.to_binary_s)
  puts reply.inspect
  
  read_socket.close
  write_socket.close
ensure
  FileUtils.rm_f socket_file('switch_manager')
end
